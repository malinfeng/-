## 树的遍历
前序遍历：  
递归：  
```cpp
void preOrder(BTNode *root) 
{
    if(root == NULL) 
	{
        return;
    }
    cout << root->value << " ";//visit操作
    preOrder(root->left);
    preOrder(root->right);
}
```
非递归：  
```cpp
void PreOrderWithoutRecursion(BTNode* root)
{
    if (root == NULL)
	{
		return;
	} 
    BTNode* p = root;
    stack<BTNode*> s;
    while (!s.empty() || p)
    {
        if (p)
        {
            cout << p->value << " ";//visit操作
            s.push(p);//访问后入栈，备用
            p = p->left;
        }
        else
        {
            p = s.top();
            s.pop();
            p = p->right;
        }
    }
}
```
中序遍历：  
递归：  
```cpp
void inOrder(BTNode *root) 
{
    if(root == NULL) 
	{
        return;
    }
    inOrder(root->left);
	cout << root->value << " ";//visit操作
    inOrder(root->right);
}
```
非递归：  
```cpp
void InOrderWithoutRecursion(BTNode* root)
{
    if (root == NULL)
	{
		return;
	}
    BTNode* p = root;
    stack<BTNode*> s;
    while (!s.empty() || p)
    {
        if (p)
        {
            s.push(p);
            p = p->left;
        }
        else
        {
            p = s.top();
            s.pop();
            cout << p->value << " ";//visit操作
            p = p->right;
        }
    }
}
```
后序遍历：  
递归：  
```cpp
void inOrder(BTNode *root) 
{
    if(root == NULL) 
	{
        return;
    }
    inOrder(root->left);
    inOrder(root->right);
	cout << root->value << " ";//visit操作
}
```
非递归：  
```cpp
//后序遍历
void PostOrderWithoutRecursion(BTNode* root)
{
    if (root == NULL)
	{
		return;
	}
    stack<BTNode*> s;
    BTNode* pCur, *pLastVisit;	//pCur:当前访问节点，pLastVisit:上次访问节点

    pCur = root;
    pLastVisit = NULL;
    while (pCur)//先把pCur移动到左子树最下边
    {
        s.push(pCur);
        pCur = pCur->left;
    }
    while (!s.empty())
    {
        pCur = s.top();//走到这里，pCur都是空，并已经遍历到左子树底端
        s.pop();
        //一个根节点被访问的前提是：无右子树或右子树已被访问过
        if (pCur->right == NULL || pCur->right == pLastVisit)
        {
            cout << p->value << " ";//visit操作
            pLastVisit = pCur;
        }
        else
        {
            s.push(pCur); 	//根节点再次入栈
            pCur = pCur->right;//进入右子树，且可肯定右子树一定不为空
            while (pCur)//重复进入到左子树底端
            {
                s.push(pCur);
                pCur = pCur->left;
            }
        }
    }
}
```