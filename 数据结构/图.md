## 图论
### 主要定义
***图***：一个图 G = (V, E)由顶点集V和边集E组成。  
***环***：图含有一条从一个顶点到自身的一条边(v, v),那么路径v,v也称做一个环。  
***圈***：图中有一个顶点，包含能够到达自身的路径，并且该路径的边数大于1。  
***连通图***：无向图中所有的顶点到其他顶点都存在一条路径，称为连通图。  
***强连通图***：有向图具有连通图的性质，称为强连通图。  
***弱连通图***：有向图去掉方向约束之后具有连通图的性质，称为弱连通图。  
***完全图***：每一个顶点之间都存在一条边。  
  
### 图的表示
***邻接矩阵***：使用一个二维数组表示，其优点是表示方法简单，但空间消耗为O(v2)。故在*稀疏图*中空间浪费比较多。  
***邻接表***：每一个顶点使用一个表来存访其邻接的顶点，其优点是节省空间，空间消耗为O(v + u)。  

### 拓扑排序
拓扑排序是针对有向无圈图的一种排序，如果存在vi->vj的路径，那么在排序中，vi必须排在vj之前。  
算法过程：  
每一次都寻找入度为0的顶点，从图中剔除该顶点并维护整个图的边集信息。  
重复以上，直到完成所有的顶点。  
```
void Topsort(Graph &G)	//拓扑排序的伪码表示
{
	int count = 0;
	Vertex v,w; 	//顶点
	
	for (count = 0; count < G.NumVertex; ++count)
	{
		v = FindVertexOfIndegreeZero(G);	//找到入度为0的顶点
		if (v == 0)
		{
			Error("Graph has a cycle!");
			break;
		}
		TopRes[count] = v;	//拓扑排序的结果
		for each w adjacent to v	//每一个该顶点的入度自减
		{
			Indegree[w]--;
		}	
	}
}
```

### 最短路径算法

#### Dijkstra算法
迪杰斯特拉算法核心思想是贪心思想，将一个问题分解到多个阶段，每个阶段都求当前阶段的最优解。  
迪杰斯特拉算法时间复杂度为On2，其优点是，在解决两点间最短距离过程中，还解决了图的单源点最短路径问题。  


#### Dijkstra算法代码实现  

[Dijkstra算法代码实现](./迪杰斯特拉算法)  

### 最小生成树

#### Prim算法


#### Kruskal算法
